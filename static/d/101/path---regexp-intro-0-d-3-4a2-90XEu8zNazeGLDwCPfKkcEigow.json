{"data":{"markdownRemark":{"html":"<h2>创建正则表达式</h2>\n<ol>\n<li>使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：</li>\n</ol>\n<pre><code class=\"language-javascript\">/*\n/pattern/flags\n*/\n\nconst regex = /ab+c/\n\nconst regex = /^[a-zA-Z]+[0-9]*\\W?_$/gi\n</code></pre>\n<p>正则表达式字面值在加载脚本后编译正则表达式。当正则表达式保持不变时，使用此方法可获得更好的性能。</p>\n<ol start=\"2\">\n<li>调用 RegExp 对象的构造函数</li>\n</ol>\n<pre><code class=\"language-javascript\">/*\nnew RegExp(pattern [, flags])\n*/\n\nlet regex = new RegExp('ab+c')\n\nlet regex = new RegExp(/^[a-zA-Z]+[0-9]*\\W?_$/, 'gi')\n\nlet regex = new RegExp('^[a-zA-Z]+[0-9]*\\\\W?_$', 'gi')\n</code></pre>\n<p>使用构造函数提供的正则表达式在运行时编译。当正则表达式的模式将会改变，或者模式未知，需要用户输入时，可以使用这种方法。</p>\n<h2>正则表达式相关的对象和方法</h2>\n<h3>RegExp 对象属性</h3>\n<p>与修饰符相关的属性</p>\n<ul>\n<li>global :返回一个布尔值，表示是否设置了 g 修饰符，该属性只读。</li>\n<li>ignoreCase :返回一个布尔值，表示是否设置了 i 修饰符，该属性只读。</li>\n<li>multiline :返回一个布尔值，表示是否设置了 m 修饰符，该属性只读。</li>\n<li>sticky :返回一个布尔值，表示是否设置了 y 修饰符，该属性只读。</li>\n<li>unicode :返回一个布尔值，表示是否设置了 u 修饰符，该属性只读。</li>\n<li>flags :返回正则表达式的修饰符。</li>\n</ul>\n<pre><code class=\"language-js\">var r = /abc/gim\n\nr.ignoreCase // true\nr.global // true\nr.multiline // true\n</code></pre>\n<p>与修饰符无关的属性</p>\n<ul>\n<li>lastIndex :返回下一次开始搜索的位置。该属性可读写，但是只在设置了 g 修饰符时有意义。</li>\n<li>source :返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</li>\n</ul>\n<pre><code class=\"language-js\">var r = /abc/gim\n\nr.lastIndex // 0\nr.source // \"abc\"\n</code></pre>\n<h3>RegExp 对象方法</h3>\n<h4>exec</h4>\n<p>如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回 null</p>\n<pre><code class=\"language-js\">var r = /a(b+)a/g\n\nvar a1 = r.exec('_abbba_aba_')\na1 // ['abbba', 'bbb']\na1.index // 1\nr.lastIndex // 6\n\nvar a2 = r.exec('_abbba_aba_')\na2 // ['aba', 'b']\na2.index // 7\nr.lastIndex // 10\n\nvar a3 = r.exec('_abbba_aba_')\na3 // null\na3.index // TypeError: Cannot read property 'index' of null\nr.lastIndex // 0\n\nvar a4 = r.exec('_abbba_aba_')\na4 // ['abbba', 'bbb']\na4.index // 1\nr.lastIndex // 6\n</code></pre>\n<h4>test</h4>\n<p>test 返回一个布尔值，表示当前模式是否能匹配参数字符串。如果正则表达式带有 g 修饰符，则每一次 test 方法都从上一次结束的位置开始向后匹配。</p>\n<pre><code class=\"language-js\">var r = /x/g\nvar s = '_x_x'\n\nr.lastIndex // 0\nr.test(s) // true\n\nr.lastIndex // 2\nr.test(s) // true\n\nr.lastIndex // 4\nr.test(s) // false\n</code></pre>\n<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>\n<pre><code class=\"language-js\">new RegExp('').test('abc')\n// true\n</code></pre>\n<h3>String 对象方法</h3>\n<h4>match</h4>\n<p>匹配成功返回一个数组，匹配失败返回 null。如果正则表达式带有 g 修饰符，则该方法与正则对象的 exec 方法行为不同，会一次性返回所有匹配成功的结果。</p>\n<pre><code class=\"language-js\">var s = 'abba'\nvar r = /a/g\n\ns.match(r) // [\"a\", \"a\"]\nr.exec(s) // [\"a\"]\n</code></pre>\n<h4>search</h4>\n<p>返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。该方法会忽略 g 修饰符。</p>\n<pre><code class=\"language-js\">var r = /x/g\nr.lastIndex = 2 // 无效\n'_x_x'.search(r) // 1\n</code></pre>\n<h4>replace</h4>\n<pre><code class=\"language-js\">str.replace(search, replacement)\n</code></pre>\n<pre><code class=\"language-js\">var str = '  #id div.class  '\n\nstr.replace(/^\\s+|\\s+$/g, '')\n// \"#id div.class\"\n</code></pre>\n<p>replace 方法的第二个参数可以使用美元符号$，用来指代所替换的内容。</p>\n<blockquote>\n<ul>\n<li>$&#x26; 指代匹配的子字符串。</li>\n<li>$` 指代匹配结果前面的文本。</li>\n<li>$' 指代匹配结果后面的文本。</li>\n<li>$n 指代匹配成功的第 n 组内容，n 是从 1 开始的自然数。</li>\n<li>$$ 指代美元符号$。</li>\n</ul>\n</blockquote>\n<pre><code class=\"language-js\">'abc'.replace('b', \"[$`-$&#x26;-$']\")\n// \"a[a-b-c]c\"\n</code></pre>\n<pre><code class=\"language-js\">var prices = {\n  pr_1: '$1.99',\n  pr_2: '$9.99',\n  pr_3: '$5.00',\n}\n\nvar template = '&#x3C;span id=\"pr_1\">&#x3C;/span>' // 这里可以放网页模块字符串\n\ntemplate.replace(/(&#x3C;span id=\")(.*?)(\">)(&#x3C;\\/span>)/g, function(match, $1, $2, $3, $4) {\n  return $1 + $2 + $3 + prices[$2] + $4\n})\n//\"&#x3C;span id=\"pr_1\">$1.99&#x3C;/span>\"\n</code></pre>\n<ul>\n<li>split :返回一个由分割后的各个部分组成的数组。</li>\n</ul>\n<pre><code class=\"language-js\">str.split(separator, [limit])\n</code></pre>\n<pre><code class=\"language-js\">// 非正则分隔\n'a,  b,c, d'.split(',')\n// [ 'a', '  b', 'c', ' d' ]\n\n// 正则分隔，去除多余的空格\n'a,  b,c, d'.split(/, */)\n// [ 'a', 'b', 'c', 'd' ]\n</code></pre>\n<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>\n<pre><code class=\"language-js\">'aaa*a*'.split(/(a*)/)\n// [ '', 'aaa', '*', 'a', '*' ]\n</code></pre>\n<h2>修饰符 flags</h2>\n<ul>\n<li>g: 全局搜索,如果正则表达式带有 g 修饰符，则每一次 test 方法都从上一次结束的位置开始向后匹配</li>\n</ul>\n<pre><code class=\"language-js\">var r = /x/g\nvar s = '_x_x'\n\nr.lastIndex // 0\nr.test(s) // true\n\nr.lastIndex // 2\nr.test(s) // true\n\nr.lastIndex // 4\nr.test(s) // false\n</code></pre>\n<ul>\n<li>i：不区分大小写</li>\n<li>m：多行搜索</li>\n</ul>\n<pre><code class=\"language-js\">var s = 'abc\\nabc\\ndab'\nvar r1 = /^ab/gm\ns.match(r1).length //2\n</code></pre>\n<pre><code class=\"language-js\">var str = 'first second\\nthird fourth\\nfifth sixth'\nvar r1 = /(\\w+)$/gm\nvar r2 = /(\\w+)$/g\nstr.match(r1) //[\"second\", \"fourth\", \"sixth\"]\nstr.match(r2) //[\"sixth\"]\n</code></pre>\n<ul>\n<li>u：Unicode 模式，会正确处理大于\\uFFFF 的字符</li>\n</ul>\n<pre><code class=\"language-js\">// 正确返回字符串长度的函数\nfunction codePointLength(text) {\n  var result = text.match(/[\\s\\S]/gu)\n  return result ? result.length : 0\n}\n\nvar s = '𠮷𠮷'\n\ns.length // 4\ncodePointLength(s) // 2\n</code></pre>\n<ul>\n<li>y：粘连模式</li>\n</ul>\n<pre><code class=\"language-js\">var s = 'aaa_aa_a'\nvar r1 = /a+/g\nvar r2 = /a+/y\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]\nr2.exec(s) // null\n</code></pre>\n<h2>正则表达式模式 pattern</h2>\n<p>pattern 包括简单字符和特殊字符。</p>\n<p>特殊字符有以下几类：</p>\n<ul>\n<li>字符类</li>\n<li>字符集</li>\n<li>边界</li>\n<li>交替</li>\n<li>群组和反向引用</li>\n<li>量词</li>\n<li>断言</li>\n</ul>\n<p>具体如下：</p>\n<h3>字符类</h3>\n<ul>\n<li>. ：除\\n, \\r, \\u2028 or \\u2029 外的任何单个字符</li>\n<li>\\d :任何数字，[0-9]</li>\n<li>\\D :非数字，<sup id=\"fnref-0-9\"><a href=\"#fn-0-9\" class=\"footnote-ref\">0-9</a></sup></li>\n<li>\\w :字母数字下划线，[A-Za-z0-9_]</li>\n<li>\\W :非字母数字下划线，<sup id=\"fnref-a-za-z0-9_\"><a href=\"#fn-a-za-z0-9_\" class=\"footnote-ref\">a-za-z0-9_</a></sup></li>\n<li>\\s :单个空格字符，[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]</li>\n<li>\\S :单个非空格字符，<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></li>\n<li>\\t :horizontal tab 匹配一个水平制表符 (U+0009)</li>\n<li>\\v :vertical tab 匹配一个垂直制表符 (U+000B)</li>\n<li>\\r :return 匹配一个回车符 (U+000D)</li>\n<li>\\n :linefeed 匹配一个换行符 (U+000A)</li>\n<li>\\f :form-feed 换页符 (U+000C)</li>\n<li>[\\b] :backspace</li>\n<li>\\0 : 匹配 null 字符（U+0000）</li>\n<li>\\uhhhh :值为 hhhh 的 UTF-16 字符</li>\n<li>\\u{hhhh},\\u{hhhhhh} :修饰符有 u 时，代表 unicode 字符</li>\n<li>\\cX :表示 Ctrl-[X]，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符。</li>\n</ul>\n<h3>字符集</h3>\n<ul>\n<li>[xyz],[a-c]</li>\n<li><sup id=\"fnref-xyz\"><a href=\"#fn-xyz\" class=\"footnote-ref\">xyz</a></sup>,<sup id=\"fnref-a-c\"><a href=\"#fn-a-c\" class=\"footnote-ref\">a-c</a></sup></li>\n<li>^ :脱字符。[^]匹配一切字符。</li>\n<li>- :连字符。表示字符的连续范围。</li>\n</ul>\n<h3>边界</h3>\n<ul>\n<li>^ :开始</li>\n<li>$ :结束</li>\n<li>\\b :单词边界</li>\n</ul>\n<pre><code class=\"language-js\">/\\bm/.exec('moon') // 'm'\n/oo\\b/.test('moon') // false\n/oon\\b/.test('moon') // true\n</code></pre>\n<p>\\B :非单词边界</p>\n<pre><code class=\"language-js\">// \\s的例子\n/\\s\\w*/.exec('hello world') // [\" world\"]\n\n// \\b的例子\n/\\bworld/.test('hello world') // true\n/\\bworld/.test('hello-world') // true\n/\\bworld/.test('hello_world') // false\n/\\bworld/.test('helloworld') // false\n\n// \\B的例子\n/\\Bworld/.test('hello-world') // false\n/\\Bworld/.test('helloworld') // true\n</code></pre>\n<h3>候选</h3>\n<ul>\n<li>x|y :x 或者 y</li>\n</ul>\n<h3>群组和反向引用</h3>\n<ul>\n<li>(x) :匹配并记住 x</li>\n</ul>\n<pre><code class=\"language-js\">var re = /(\\w+)\\s(\\w+)/\nvar str = 'John Smith'\nvar newstr = str.replace(re, '$2, $1') //$n 引用括号匹配字符串\nprint(newstr) // Smith, John\n</code></pre>\n<ul>\n<li>\n<p>\\n :反向引用</p>\n</li>\n<li>\n<p>(?:x) :匹配且不记住 x</p>\n</li>\n</ul>\n<h3>量词</h3>\n<ul>\n<li>x* : 匹配 x 0 次或多次</li>\n<li>x+ : 匹配 x 1 次或多次</li>\n<li>x? :0 or 1</li>\n<li>x{n} : n 次</li>\n<li>x{n,} :至少 n 次</li>\n<li>x{n,m} :至少 n 次，至多 m 次</li>\n<li>x*? :非贪婪模式</li>\n</ul>\n<h3>断言</h3>\n<ul>\n<li>x(?=y) :先行断言。只有 y 跟随 x 时才匹配 x</li>\n<li>x(?!y) :先行否定断言。只有 y 不跟随 x 时才匹配 x</li>\n</ul>\n<h3>贪婪模式</h3>\n<pre><code class=\"language-js\">var s = 'aaa'\ns.match(/a+/) // [\"aaa\"]\n</code></pre>\n<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>\n<pre><code class=\"language-js\">var s = 'aaa'\ns.match(/a+?/) // [\"a\"]\n</code></pre>\n<h3>组匹配</h3>\n<pre><code class=\"language-js\">;/fred+/.test('fredd') / // true\n  fred +\n  /.test('fredfred') / / true\n</code></pre>\n<p>在正则表达式内部，可以用\\n 引用括号匹配的内容，n 是从 1 开始的自然数，表示对应顺序的括号。</p>\n<pre><code class=\"language-js\">;/(.)b(.)\\1b\\2/.test('abcabc')\n// true\n</code></pre>\n<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>\n<pre><code class=\"language-js\">var tagName = /&#x3C;([^>]+)>[^&#x3C;]*&#x3C;\\/\\1>/\ntagName.exec('&#x3C;b>bold&#x3C;/b>')[1]\n// 'b'\n</code></pre>\n<pre><code class=\"language-js\">var html = '&#x3C;b class=\"hello\">Hello&#x3C;/b>&#x3C;i>world&#x3C;/i>'\nvar tag = /&#x3C;(\\w+)([^>]*)>(.*?)&#x3C;\\/\\1>/g\n\nvar match = tag.exec(html)\n\nmatch[1] // \"b\"\nmatch[2] // \" class=\"hello\"\"\nmatch[3] // \"Hello\"\n\nmatch = tag.exec(html)\n\nmatch[1] // \"i\"\nmatch[2] // \"\"\nmatch[3] // \"world\"\n</code></pre>\n<pre><code class=\"language-js\">// 获取url信息\nvar url = /(http|ftp):\\/\\/([^/\\r\\n]+)(\\/[^\\r\\n]*)?/\n\nurl.exec('http://javascript.ruanyifeng.com/stdlib/regexp.html')\n\n//  [\"http://javascript.ruanyifeng.com/stdlib/regexp.html\", \"http\", \"javascript.ruanyifeng.com\", \"/stdlib/regexp.html\"]\n</code></pre>\n<pre><code class=\"language-js\">// 获取url参数值\nvar url = '/rtcp-web/libra/mw/list.do?sysSimpleName=rtcp&#x26;_=1500608993777'\n\nfunction getParameter(url, name) {\n  var reg = new RegExp('(?:^|\\\\?|&#x26;)' + name + '=([^&#x26;]*)(?:&#x26;|#|$)', 'gi')\n  var match = reg.exec(url)\n  if (match) {\n    return match[1]\n  } else {\n    return null\n  }\n}\n\ngetParameter(url, 'sysSimpleName') // rtcp\n</code></pre>\n<pre><code class=\"language-js\">// get all url parameter\n\nconst url = '/rtcp-web/libra/mw/list.do?sysSimpleName=rtcp&#x26;_=1500608993777'\n\nconst reg = /(\\?|\\&#x26;)([^=]+)\\=([^&#x26;]+)/g\n\nconst res = url.match(reg)\n\n// [\"?sysSimpleName=rtcp\", \"&#x26;_=1500608993777\"]\n</code></pre>\n<p>template example</p>\n<pre><code class=\"language-js\">function render(template, context) {\n  return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key.trim()])\n}\n\nconst template = '{{name}}很厉害的name正则，{{age }}ff'\n\nconst context = { name: 'xiaoming', age: '12' }\n\nconsole.log(render(template, context))\n</code></pre>\n<h3>非捕获组</h3>\n<p>(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容</p>\n<h3>其他</h3>\n<p>后行断言、具名组匹配等，目前处于提案阶段。</p>\n<h2>参考资料</h2>\n<ul>\n<li>\n<p><a href=\"http://javascript.ruanyifeng.com/stdlib/regexp.html\">http://javascript.ruanyifeng.com/stdlib/regexp.html</a></p>\n</li>\n<li>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/regex\">http://es6.ruanyifeng.com/#docs/regex</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p>\n</li>\n<li>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp</a></p>\n</li>\n<li>\n<p><a href=\"http://www.cnblogs.com/rubylouvre/archive/2010/03/09/1681222.html\">http://www.cnblogs.com/rubylouvre/archive/2010/03/09/1681222.html</a></p>\n</li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p> \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"正则表达式用法"}}},"pageContext":{"slug":"/regexp-intro/"}}